<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>单调栈</title>
    <link href="/2020/02/08/%E5%8D%95%E8%B0%83%E6%A0%88%20&amp;%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/"/>
    <url>/2020/02/08/%E5%8D%95%E8%B0%83%E6%A0%88%20&amp;%20%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97/</url>
    
    <content type="html"><![CDATA[<h2 id="单调栈-单调队列"><a href="#单调栈-单调队列" class="headerlink" title="单调栈 &amp; 单调队列"></a>单调栈 &amp; 单调队列</h2><h3 id="单调栈"><a href="#单调栈" class="headerlink" title="单调栈"></a>单调栈</h3><p>作用：$O(n)$时间内找出数组中每个数左(右)边第一个比它小(大)的数</p><p>以<strong>左</strong>和<strong>小</strong>为例</p><p><strong>关键：如果左边的数比当前这个数大或等于这个数，那么这个数一定不会被用到</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++">stack&lt;<span class="hljs-type">int</span>&gt; stk;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i ++) &#123;<br><span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">size</span>() &amp;&amp; a[stk.<span class="hljs-built_in">top</span>()] &gt;= a[i]) stk.<span class="hljs-built_in">pop</span>(); <span class="hljs-comment">//出栈 直到栈为空或栈顶小于当前元素</span><br><span class="hljs-comment">// 按题意 中间会有一些操作</span><br>    stk.<span class="hljs-built_in">push</span>(i);  <span class="hljs-comment">// 最后入栈</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>性质：出栈时，右边第一个比栈顶元素小的元素即为当前数</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">int</span> w[N]; <span class="hljs-comment">// 用来存储右边第一个比自身小的元素</span><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i ++) &#123; <span class="hljs-comment">//小标从1开始，若右边不存在比自身小的元素，则为初始值0</span><br><span class="hljs-keyword">while</span>(stk.<span class="hljs-built_in">size</span>() &amp;&amp; a[stk.<span class="hljs-built_in">top</span>()] &gt; a[i]) <span class="hljs-comment">// 这里是大于而非大于等于</span><br>        w[stk.<span class="hljs-built_in">top</span>()] = i, stk.<span class="hljs-built_in">pop</span>();<br>    stk.<span class="hljs-built_in">push</span>(i);<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://www.acwing.com/problem/content/832/">单调栈模版</a></p><p><a href="https://www.acwing.com/problem/content/description/602/">仰视奶牛</a> 利用性质</p><p><a href="https://www.acwing.com/problem/content/133/">直方图中的最大矩形</a> 求直方图最大对齐矩形 即求每一个元素的<strong>左右两边</strong>第一个比它<strong>小</strong>的元素</p><p><a href="https://www.acwing.com/problem/content/154/">城市游戏</a>  转化为求直方图中的最大矩形 (枚举底边)</p>]]></content>
    
    
    <categories>
      
      <category>work</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algo</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
